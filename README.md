### Пояснення до коду 1:

Цей код визначає асинхронну функцію runSequent, яка приймає масив array і функцію зворотнього виклику callback. Функція callback виконується послідовно для кожного елемента масиву і повертає об'єкт типу Promise<R>, де R - тип результату.

Основна ідея функції runSequent полягає у послідовному виконанні асинхронних операцій для кожного елемента масиву. Функція використовує цикл for для проходження по елементам масиву array. На кожній ітерації викликається функція callback з поточним елементом і його індексом. Отриманий результат додається до масиву results.

Функція runSequent повертає проміс, що містить масив результатів results.

В нижній частині коду створюється асинхронна функція, яка демонструє використання функції runSequent. Створюється масив myArray з рядками ["one", "two", "three"]. Функція runSequent викликається з цим масивом і функцією callback, яка просто повертає об'єкт з поточним елементом і його індексом. Отримані результати виводяться на консоль.

### Пояснення до коду 2:
Цей код визначає масив array, який містить числа, і викликає функцію arrayChangeDelete з цим масивом і функцією зворотнього виклику (item) => item % 2 === 0.

Функція arrayChangeDelete визначається з використанням загального типу T для масиву і зворотнього виклику. Вона приймає масив array і функцію зворотнього виклику callback, яка приймає елемент масиву типу T і повертає значення типу boolean.
В середині функції визначений порожній масив deletedElements, який буде містити видалені елементи. Далі використовується цикл for, щоб пройтися по кожному елементу масиву array. У тілі циклу перевіряється, чи задовольняє поточний елемент умову, визначену функцією callback. Якщо умова виконується, то елемент додається до масиву deletedElements за допомогою методу push, а потім видаляється зі зміненого масиву array за допомогою методу splice.
На кінці функції повертається масив deletedElements, який містить видалені елементи з вхідного масиву array.
В останному рядку коду викликається console.log для виведення масиву deletedElements на консоль.

### Пояснення до коду 3:
Цей код використовує модулі os, _process та systeminformation для отримання та виведення інформації про операційну систему, апаратну архітектуру, поточного користувача, інформацію про процесор, температуру CPU, інформацію про графічні контролери, інформацію про зарядку батареї та решту часу роботи.

Функція operatingSystem визначається з використанням async/await для роботи з асинхронними операціями. В середині функції виконуються наступні дії:

Виводиться тип операційної системи за допомогою os.type().
Виводиться архітектура системи за допомогою os.arch().
Виводиться ім'я поточного користувача за допомогою os.userInfo().username.
Виводиться модель першого ядра процесора за допомогою os.cpus()[0].model.
Отримується і виводиться температура процесора за допомогою si.cpu().
Отримується та виводиться інформація про графічні контролери за допомогою si.graphics(). Використовується метод map, щоб пройтися по кожному контролеру та вивести інформацію про виробника (vendor) та модель (model).
Отримується та виводиться інформація про зарядку батареї за допомогою si.battery(). Виводиться стан зарядки (isCharging), відсоток заряду (percent) та залишений час роботи (timeRemaining).
На початку коду викликається функція operatingSystem(), щоб вивести інформацію про операційну систему.

Після цього, за допомогою process.stdin.on('data', (data: number) => { ... }), встановлюється обробник події для читання введення з консолі. Коли отримується дані, перевіряється, чи є введене значення числом за допомогою isNaN().


### Пояснення до коду 4
У цьому коді здійснюються наступні дії:
Імпортується необхідні модулі для роботи з файлами (fs), роботи з шляхами (path) і здійснення мережевих запитів (node-fetch).
Встановлюється шлях до файлу links.json, який містить дані у форматі JSON про посилання.
Зчитується вміст файлу links.json за допомогою fs.readFileSync і перетворюється в об'єкт jsonData. Потім цей об'єкт парситься в масив рядків links за допомогою JSON.parse.
Створюється директорія JSON_Links_pages за допомогою fs.mkdir, де будуть зберігатись результати.
Встановлюються налаштування для мережевого запиту (в даному випадку метод "GET") у змінну settings.
Запускається цикл, який пройде по кожному посиланню в масиві links.
Для кожного посилання виконується мережевий запит за допомогою fetch, використовуючи встановлені налаштування settings.
Після отримання відповіді, її текстове представлення отримується за допомогою методу .text().
Отриманий текст записується у окремий текстовий файл за допомогою fs.writeFile, який зберігається у директорії JSON_Links_pages. Назва файлу формується з префіксу "textfile" та індексу посилання i.
Після успішного запису файлу в консоль виводиться повідомлення про успішне завершення запису.

### Пояснення до коду 5
Даний код визначає клас MyEventEmitter, який є простою реалізацією подійної моделі (EventEmitter) в JavaScript/TypeScript.
Основні методи та їх функціональність в класі MyEventEmitter:
registerHandler(eventType: string, handler: EventHandler): void: Цей метод реєструє обробники подій для певного типу події (eventType). Він додає обробник (handler) до масиву обробників, пов'язаних з цим типом події.
unregisterHandler(eventType: string, handler: EventHandler): void: Цей метод скасовує реєстрацію обробника подій для певного типу події (eventType). Він видаляє обробник з масиву обробників для цього типу події.
emitEvent(eventType: string, ...args: any[]): void: Цей метод викликає подію з певним типом (eventType). Він отримує всі обробники, пов'язані з цим типом події, і викликає кожен з них, передаючи аргументи (args).
Код після визначення класу MyEventEmitter створює екземпляр цього класу під назвою emitter. Потім реєструється обробник події "userUpdated", який просто виводить повідомлення в консоль. Нарешті, викликається подія "userUpdated", що призводить до виклику зареєстрованого обробника і виводу повідомлення "Обліковий запис користувача оновлено" у консоль.

